# FastAPI 项目概览

## 🎯 项目目标

通过一个完整的用户管理系统，学习 FastAPI、SQLAlchemy 和 Pydantic 的核心概念和最佳实践。

## 📐 项目架构

### 三层架构

```
┌─────────────────────────────────────────┐
│          API 层 (FastAPI)               │
│  - 路由定义                              │
│  - 请求处理                              │
│  - 响应格式化                            │
│  - 使用 Pydantic Schemas                │
└─────────────────────────────────────────┘
                  ↕
┌─────────────────────────────────────────┐
│         业务逻辑层 (CRUD)                │
│  - 业务逻辑                              │
│  - 数据验证                              │
│  - 事务处理                              │
└─────────────────────────────────────────┘
                  ↕
┌─────────────────────────────────────────┐
│       数据层 (SQLAlchemy Models)        │
│  - ORM 模型                             │
│  - 数据库表定义                          │
│  - 关系定义                              │
└─────────────────────────────────────────┘
```

### 为什么要分层？

1. **关注点分离**：每层只关注自己的职责
2. **易于测试**：可以独立测试每一层
3. **代码复用**：CRUD 层可以在多个端点中复用
4. **易于维护**：修改一层不影响其他层

## 🔑 核心概念

### 1. Models vs Schemas

| 特性 | SQLAlchemy Models | Pydantic Schemas |
|------|-------------------|------------------|
| 用途 | 数据库表结构 | API 数据验证 |
| 继承 | `Base` | `BaseModel` |
| 字段定义 | `mapped_column()` | `Field()` |
| 验证 | 数据库约束 | Python 类型+验证器 |
| 序列化 | 需要手动 | 自动 |

**示例：**

```python
# Model (数据库层)
class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    email: Mapped[str] = mapped_column(String, unique=True)

# Schema (API 层)
class UserCreate(BaseModel):
    email: EmailStr = Field(..., description="用户邮箱")
```

### 2. 依赖注入 (Dependency Injection)

FastAPI 的核心特性，用于：
- 复用逻辑
- 提高可测试性
- 管理资源（如数据库连接）

**基本用法：**

```python
# 定义依赖
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 使用依赖
@app.get("/users/")
def get_users(db: Session = Depends(get_db)):
    return user_crud.get_multi(db)
```

**依赖链：**

```python
# 第一层依赖
def get_db():
    ...

# 第二层依赖（依赖于 get_db）
def get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)):
    ...

# 第三层依赖（依赖于 get_current_user）
def get_current_active_user(current_user: User = Depends(get_current_user)):
    ...
```

### 3. CRUD 模式

**C**reate, **R**ead, **U**pdate, **D**elete

- 将数据库操作封装在 CRUD 类中
- 提供统一的接口
- 易于测试和复用

**通用基类：**

```python
class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    def get(self, db: Session, id: int) -> ModelType | None
    def get_multi(self, db: Session, skip: int = 0, limit: int = 100) -> list[ModelType]
    def create(self, db: Session, obj_in: CreateSchemaType) -> ModelType
    def update(self, db: Session, db_obj: ModelType, obj_in: UpdateSchemaType) -> ModelType
    def delete(self, db: Session, id: int) -> ModelType | None
```

## 🔐 认证与授权

### JWT 流程

```
1. 用户登录
   ↓
2. 验证用户名和密码
   ↓
3. 生成 JWT token
   ↓
4. 返回 token 给客户端
   ↓
5. 客户端在后续请求中携带 token
   ↓
6. 服务端验证 token
   ↓
7. 返回受保护的资源
```

### JWT Token 结构

```
Header.Payload.Signature

Payload 包含:
{
  "sub": 1,           # subject: 用户 ID
  "exp": 1640000000,  # expiration: 过期时间
  "iat": 1639900000   # issued at: 签发时间
}
```

## 📊 数据流

### 创建用户流程

```
客户端 POST /api/v1/auth/register
    ↓
API 端点接收 UserCreate Schema
    ↓
验证数据（Pydantic 自动）
    ↓
检查用户是否存在（CRUD）
    ↓
创建用户（CRUD，密码哈希）
    ↓
保存到数据库（SQLAlchemy）
    ↓
返回 UserResponse Schema
    ↓
客户端收到 JSON 响应
```

### 获取用户信息流程

```
客户端 GET /api/v1/auth/me
    ↓
提取 Authorization header 中的 token
    ↓
验证 token（依赖注入）
    ↓
从 token 中获取 user_id
    ↓
从数据库查询用户（CRUD）
    ↓
转换为 Pydantic Schema
    ↓
返回 JSON 响应
```

## 🎨 代码组织原则

### 1. 单一职责原则

每个模块只做一件事：
- `models/` - 只定义数据库表
- `schemas/` - 只定义 API 数据结构
- `crud/` - 只处理数据库操作
- `api/endpoints/` - 只定义路由和处理请求

### 2. 依赖倒置原则

高层模块不依赖低层模块，都依赖抽象：
- API 层不直接操作数据库
- 通过 CRUD 层抽象数据访问
- 通过 Schemas 抽象数据结构

### 3. 开闭原则

对扩展开放，对修改关闭：
- 通用 CRUD 基类可扩展
- 新增模型只需继承基类
- 新增端点只需添加路由

## 🚀 下一步

1. 理解项目结构和文件职责
2. 学习 Models 和 Schemas 的定义
3. 掌握 CRUD 操作
4. 实践 API 端点开发
5. 理解认证流程
6. 扩展项目（添加文章、评论等功能）


## 📁 Celery & LLM推荐的目录结构

### **Celery 异步任务**

```bash
app/
├── tasks/                  # Celery 任务目录
│   ├── __init__.py
│   ├── user_tasks.py      # 用户相关任务
│   ├── email_tasks.py     # 邮件任务
│   └── llm_tasks.py       # LLM 相关任务
├── core/
│   ├── celery.py          # Celery 配置和实例
│   └── ...
└── worker.py              # Celery Worker 入口（可选）
```

### **LLM 调用**

```bash
app/
├── services/              # 业务服务层（新增）
│   ├── __init__.py
│   ├── llm/              # LLM 服务
│   │   ├── __init__.py
│   │   ├── base.py       # LLM 基类/接口
│   │   ├── openai.py     # OpenAI 客户端
│   │   ├── claude.py     # Claude 客户端
│   │   └── prompts/      # 提示词模板
│   │       ├── __init__.py
│   │       └── templates.py
│   └── email.py          # 邮件服务（示例）
```

## 📋 完整建议结构

```bash
fastapi-learning/
├── app/
│   ├── api/              # 现有：API 路由
│   ├── core/             # 现有：核心配置
│   │   ├── celery.py     # 新增：Celery 配置
│   │   └── ...
│   ├── crud/             # 现有：数据库操作
│   ├── models/           # 现有：SQLAlchemy 模型
│   ├── schemas/          # 现有：Pydantic 模型
│   ├── tasks/            # 新增：Celery 任务
│   ├── services/         # 新增：业务服务层
│   │   └── llm/         # LLM 相关服务
│   └── utils/            # 新增：工具函数（可选）
```

## 💡 使用示例

### 1. Celery 配置 (`app/core/celery.py`)

```python
from celery import Celery
from app.core.config import settings

celery_app = Celery(
    "worker",
    broker=settings.CELERY_BROKER_URL,
    backend=settings.CELERY_RESULT_BACKEND,
)

celery_app.conf.task_routes = {
    "app.tasks.llm_tasks.*": "llm-queue",
    "app.tasks.email_tasks.*": "email-queue",
}
```

### 2. LLM 服务 (`app/services/llm/openai.py`)

```python
from openai import AsyncOpenAI

class OpenAIService:
    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
    
    async def chat(self, messages: list):
        response = await self.client.chat.completions.create(...)
        return response
```

### 3. LLM 任务 (`app/tasks/llm_tasks.py`)

```python
from app.core.celery import celery_app
from app.services.llm.openai import OpenAIService

@celery_app.task
def process_with_llm(text: str):
    service = OpenAIService()
    result = service.chat([{"role": "user", "content": text}])
    return result
```

### 4. API 中调用 (`app/api/v1/endpoints/ai.py`)

```python
from app.services.llm.openai import OpenAIService
from app.tasks.llm_tasks import process_with_llm

@router.post("/chat")
async def chat(message: str):
    # 同步调用
    service = OpenAIService()
    result = await service.chat([...])
    
    # 或异步任务
    task = process_with_llm.delay(message)
    return {"task_id": task.id}
```